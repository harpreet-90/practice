import java.util.*;

public class Main {
	final int VERTEX_COUNT = 2000;
//	public static void main(String[] args)
//	{
//		Backtracking b = new Backtracking();
//		int[] a = {1, 2, 3};
//		MathUtils mu = new MathUtils();
//		System.out.println(mu.isPrime(42));
//		mu.GenerateAllPrimeNumbersInGivenRange(1, 10);
//		System.out.println(b.killQueenByHorseFast(new Position(1,0), new Position(2,1)));
//		ThreadClass tc = new ThreadClass();  
//		Thread t1 =new Thread(tc);
//		Thread t2 =new Thread(tc);
//		Thread t3 =new Thread(tc);
//		Thread t4 =new Thread(tc);
//		Thread t5 =new Thread(tc);
//		t1.start(); 
//		t2.start(); 
//		t3.start(); 
//		t4.start(); 
//		t5.start(); 
//		
		
//		ArrayList<Integer> preOrder = new ArrayList<Integer>();
//		preOrder.add(5);
//		preOrder.add(3);
//		preOrder.add(4);
//		preOrder.add(9);
//		preOrder.add(7);
//		preOrder.add(6);
//		ArrayList<Integer> inOrder = new ArrayList<Integer>();
//		inOrder.add(3);
//		inOrder.add(4);
//		inOrder.add(5);
//		inOrder.add(6);
//		inOrder.add(7);
//		inOrder.add(9);
		BinaryTree bst1 = new BinaryTree();
		BinaryTree bst2 = new BinaryTree();
//		bst.BSTfromPreOrder();
//		bst.levelOrderTrav();
//		DoublyLinkedList dll = new DoublyLinkedList();
//		dll.insert(new DoublyLinkListNode(1));
//		dll.insert(new DoublyLinkListNode(2));
//		dll.insert(new DoublyLinkListNode(3));
//		dll.insert(new DoublyLinkListNode(4));
//		dll.insert(new DoublyLinkListNode(5));
//		dll.insert(new DoublyLinkListNode(6));
//		dll.printDll(Direction.FORWARD);
//		dll.printDll(Direction.REVERSE);
//		bst.root = new BSTNode(4);
//		bst.root.left = new BSTNode(2);
//		bst.root.left.right = new BSTNode(3);
//		bst.root.right = new BSTNode(5);
//		bst.root.right.left = new BSTNode(6);
//		bst.root.right.left.right = new BSTNode(8);
//		bst.root.right.right = new BSTNode(7);
//		bst.root.right.right.right = new BSTNode(9);
//		bst.root.right.right.right.right = new BSTNode(10);
//		bst.balanceInsert(1);
//		bst.balanceInsert(2);
//		bst.balanceInsert(4);
//		bst.balanceInsert(3);
//		bst.balanceInsert(8);
//		bst.balanceInsert(10);
//		bst.balanceInsert(11);
//		bst.balanceInsert(5);
//		bst.balanceInsert(7);
//		bst.balanceInsert(12);
//		bst.balanceInsert(18);
//		
//		bst1.root = new BSTNode(1);
//		bst1.root.left = new BSTNode(2);
//		bst1.root.right = new BSTNode(3);
//		bst1.root.left.left = new BSTNode(4);
//		bst1.root.left.right = new BSTNode(5);
//		bst1.root.left.right.left = new BSTNode(6);
//		bst1.root.left.right.right = new BSTNode(7);
//		bst1.root.left.left.left = new BSTNode(8);
//		
//		
//		bst2.root = new BSTNode(1);
//		bst2.root.right = new BSTNode(2);
//		bst2.root.left = new BSTNode(3);
//		bst2.root.right.right = new BSTNode(4);
//		bst2.root.right.left = new BSTNode(5);
//		bst2.root.right.left.right = new BSTNode(6);
//		bst2.root.right.left.left = new BSTNode(7);
//		bst2.root.right.right.right = new BSTNode(8);
//		bst2.printPathOfGivenNodeInBT(3);
//		bst2.printPathOfGivenNodeInBT(5);
//		bst2.printPathOfGivenNodeInBT(8);
		
//		int arr[] = {-1, -2, -3, -4}; 
//		ArrayUtils au = new ArrayUtils();
//		System.out.println(au.findTrappingWater(arr));
//		System.out.println(au.subbArrayWithMaxSum(arr));
		//System.out.println(bst1.ifTwoTreesAreMirror(bst1.root, bst2.root));
//		System.out.println(bst.checkSortedSequence(seq));
//		bst.findKthLargestNoInBST(6);
//		bst.findKthLargestNoInBST(0);
		//bst.findKthLargestNoInBST(5);
//		System.out.println(bst.findDistanceInTwoNodes(3, 12));
//		System.out.println(bst.eachNodeHasOneChild(bst.root));
//		bst.inOrderTrav();
//		bst.printReverseTreePathUtil(bst.root, 4);
//		System.out.println();
//		bst.preOrderTrav();
//		System.out.println();
//		bst.postOrderTrav();
//		System.out.println();
//		bst.levelOrderTrav();
//		System.out.println(bst.find(4));
//		System.out.println(bst.find(7));
//		bst.bstToDll();
//		System.out.println(bst.isBST());
//	}
}

